# -*- coding: utf-8 -*-
"""NOR_unsaturate.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1X7XqXL9d3uL9pFZ1D8qGZt7xXz3CKlsw
"""

from google.colab import drive
drive.mount('/content/gdrive', force_remount=True)
root_dir = "/content/gdrive/My Drive/"
base_dir = root_dir + 'Individual_reward_networks/'
import os
import sys
sys.path.append(base_dir)
os.chdir(base_dir)

from network_evaluation_functions import evaluate_network2, get_entropy, get_entropy_per_layer, graph_connections, difference_evaluation2
from matplotlib import pyplot as plt
from all_versus_1_MNIST import transform_data2
import pandas as pd
import pickle
from torch.utils.data import Dataset as Dataset
from one_v_all_function import one_vs_all_data
from all_versus_1_MNIST import transform_data
from restricted_NOR_networks import restricted_NOR_network
import pickle

from mutation_network import mutation_networks
example_network = mutation_networks([5, 4, 3, 2, 1], [3, 3, 3, 3, 2], [2])

rn1 = mutation_networks([9, 9, 6, 3, 1], [3, 3, 3, 3, 2], [9])
rn2 = mutation_networks([9, 9, 6, 3, 1], [3, 3, 3, 3, 2], [9])
rn3 = mutation_networks([9, 9, 6, 3, 1], [3, 3, 3, 3, 2], [9])
rn4 = mutation_networks([9, 9, 6, 3, 1], [3, 3, 3, 3, 2], [9])
rn5 = mutation_networks([9, 9, 6, 3, 1], [3, 3, 3, 3, 2], [9])
rn6 = mutation_networks([9, 9, 6, 3, 1], [3, 3, 3, 3, 2], [9])
rn7 = mutation_networks([9, 9, 6, 3, 1], [3, 3, 3, 3, 2], [9])
rn8 = mutation_networks([9, 9, 6, 3, 1], [3, 3, 3, 3, 2], [9])
rn9 = mutation_networks([9, 9, 6, 3, 1], [3, 3, 3, 3, 2], [9])
rn0 = mutation_networks([9, 9, 6, 3, 1], [3, 3, 3, 3, 2], [9])

networks = [rn0, rn1, rn2, rn3, rn4, rn5, rn6, rn7, rn8, rn9]


train_size = 60000
MNIST_data = pd.read_csv('TSNE_all_untouched')
MNIST_train = MNIST_data[:train_size]
MNIST_test = MNIST_data[train_size:]

class MNIST_set(Dataset):
    def __init__(self, X, y):
        self.X = X
        self.y = y

    def __len__(self):
        return len(self.X)

    def __getitem__(self, item):
        X_p = self.X[item]
        y_p = self.y[item]
        return X_p, y_p

with open('normal_strat_40+30.pkl', 'rb') as f:
    strats = pickle.load(f)


def retrain_unsaturate(my_network,num_epochs, learning_rate, dataset, val_dataset, num_layers_unsaturate):
    print('Starting Training:')
    entropies = []
    layer_entropies = []
    validation_scores = []
    training_scores =[]
    nls = num_layers_unsaturate
    nl = len(my_network.neuron_list) - 1
    for i in range(nls):
        layer = my_network.neuron_list[nl-i]
        for j in range(len(layer)):
            neuron = layer[j]
            neuron.mixed_strategy = neuron.initialize_mixed_strategy()
        # for neuron in layer:
        #     neuron.mixed_strategy = neuron.initialize_mixed_strategy()
    for epoch in range(num_epochs):
        print('Starting Epoch:', epoch)
        layer_entropies.append(get_entropy_per_layer(my_network))
        entropies.append(get_entropy(my_network))
        print('Entropy: ', entropies[-1])
        validation_score = evaluate_network2(my_network, val_dataset)
        print('Validation Score: ', validation_score)
        validation_scores.append(validation_score)
        epoch_accuracy = 0
        for id, data in enumerate(dataset):
            X, y = data
            output, strategies, _ = my_network.forward(X)
            output = int(output[0])
            error = (y - output) ** 2
            if error == 0:
                epoch_accuracy += 1
            fitness = 1 - error
            for i in range(nls):
                for j in range(len(my_network.neuron_list[nl-i])):
                    neuron = my_network.neuron_list[nl-i][j]
                    chosen_strategy = strategies[nl-i][j]
                    neuron_fitness = fitness
                    neuron.mixed_strategy = [(1 - (learning_rate * fitness)) * item for item in neuron.mixed_strategy]
                    neuron.mixed_strategy[chosen_strategy] += learning_rate * fitness
                    neuron.mixed_strategy = [item / sum(neuron.mixed_strategy) for item in neuron.mixed_strategy]
        training_scores.append(epoch_accuracy/len(dataset))
        print('Training Score:', training_scores[-1])
    columns = []
    for i in range(my_network.num_layers):
        j = i+1
        columns.append('Layer ' + str(j))
    layer_dataframe = pd.DataFrame(layer_entropies, columns=columns)
    plt.figure()
    layer_dataframe.plot()

    plt.xlabel("Epoch")
    plt.ylabel("Mean Layer Entropy")
    plt.title("LR:" + str(learning_rate))
    plt.grid(True)
    plt.show()

    plt.plot(training_scores)
    plt.xlabel("Epoch")
    plt.ylabel("Training Accuracy")
    plt.title("LR:" + str(learning_rate))
    plt.grid(True)
    plt.show()

    plt.plot(validation_scores)
    plt.xlabel("Epoch")
    plt.ylabel("Validation Accuracy")
    plt.title("LR:" + str(learning_rate))
    plt.grid(True)
    plt.show()

    return my_network.save_mixed_strategy(), layer_dataframe, validation_scores, training_scores


classifier_strategies = []
classifier_layer_entropies = []
classifier_train_scores = []
classifier_validation_scores = []
for i in range(10):
    #NOR_network = restricted_NOR_network([9, 9, 9, 6, 3, 2, 1], [9])
    NOR_network = networks[i]
    NOR_network.load_mixed_strategy(strats[i])
    dataframe = one_vs_all_data(MNIST_train, i)
    dataframe_val = one_vs_all_data(MNIST_test, i)
    X_train, y_train = transform_data(dataframe)
    X_val, y_val = transform_data(dataframe_val)
    train_dataset = MNIST_set(X_train, y_train)
    val_dataset = MNIST_set(X_val, y_val)
    strategy, entropies, val_score, train_score= retrain_unsaturate(NOR_network, 30, 0.001, train_dataset, val_dataset, 3)
    classifier_strategies.append(strategy)
    classifier_layer_entropies.append(entropies)
    classifier_train_scores.append(train_score)
    classifier_validation_scores.append(val_score)


import pickle
with open('normal_unsat_train_30.pkl', 'wb') as f:
    pickle.dump(classifier_train_scores, f)
    
with open('normal_unsat4_val_30.pkl', 'wb') as f:
    pickle.dump(classifier_validation_scores, f)
    
with open('normal_unsat4_strat_30.pkl', 'wb') as f:
    pickle.dump(classifier_strategies, f)
    
with open('normal_unsat4_ent_30.pkl', 'wb') as f:
    pickle.dump(classifier_layer_entropies, f)